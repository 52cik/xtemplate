<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>xtemplate - 构建前端 DSL template</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="nico 0.5.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link type="image/x-icon" href="/favicon.ico" rel="icon">
    <link rel="stylesheet" href="../../static/css/normalize.css" />
    <link rel="stylesheet" href="../../static/css/site.css" />
    <link rel="stylesheet" href="../../static/css/solarized.css" />
<script>
if (!location.port) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-50522089-2', 'auto');
  ga('send', 'pageview');
}
</script>
<script src="../../static/js/sea.js?nowrap"></script>

<script>
  seajs.config({
    base: "../../",
    alias: {}
  });
</script>
    <!--[if lt IE 9]>
    <script src="../../static/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  <body class="spmjs">
    <div class="body-wrapper">
      <aside class="sidebar-wrapper">
      <h1>
          <a href="../../">Xtemplate</a>
      </h1>
      <p class="sidebar-version">Version: <a href="http://spmjs.io/package/xtemplate" title="">4.0.3</a></p>
        <p class="sidebar-description" data-keyword="template"></p>
        <a class="sidebar-source" href="http://github.com/kissyteam/xtemplate" target="_blank">View the Project</a>
        <ul class="sidebar-navigation" role="navigation">
          <li><a href="../../">Doc</a></li>
          <li><a class="test-link" href="../../tests/runner.html" target="_blank">Test</a></li>
          <li><a class="issue-link" href="http://github.com/kissyteam/xtemplate/issues" target="_blank">Issues</a></li>
        </ul>
        
<ol class="sidenav">
  <li><a href="impl.html">构建前端 DSL template</a></li>
  <li><a href="introduce.html">introduce xtemplate</a></li>
  <li><a href="kg-xtemplate.html">xtemplate on kg</a></li>
  <li><a href="performance-hint.html">performance hint</a></li>
  <li><a href="server-xtemplate.html">xtemplate on server</a></li>
  <li><a href="use-on-browser.html">use XTemplate on browser</a></li>
</ol>

        <div class="qrcode-wrapper">
          <i class="icon iconfont">
            &#x3433;
            <div class="qrcode" id="qrcode"></div>
          </i>
        </div>
      </aside>
      <div class="content-wrapper">
        
<article class="hentry">
  <h1 class="entry-title">构建前端 DSL template</h1>
  <div class="entry-content">
    <p>目前在传统的软件开发领域 <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> 已经比较普遍，
特别是 <a href="http://martinfowler.com/">Martin Fowler</a> 的突出贡献。
而在前端领域尚较少涉及，而如果在前端开发中合理使用 DSL 同样也可以有效得<strong>减少代码数量，提高可读性</strong>，常见的一个应用场景即前端模板的构建。
本质上说模板也是一个微型语言，因此可以从DSL的角度着手，使用工具快速构建一个适合于特定前端框架的模板引擎。
本文将以 <a href="http://docs.kissyui.com/docs/html/demo/component/xtemplate/index.html">KISSY XTemplate</a>
为例介绍如何构建前端的 DSL。</p>
<p>注：
本文持续更新地址：
<a href="https://github.com/kissyteam/kissy/blob/master/src/xtemplate/impl.html">xtemplate at github</a>.
<a href="http://docs.kissyui.com/docs/html/tutorials/kissy/component/xtemplate/impl.html">xtemplate at docs.kissyui.com</a>.</p>
<h2 id="首先-npm-安装-kissy">首先 npm 安装 kissy<a href="#首先-npm-安装-kissy" class="anchor">¶</a></h2><pre> npm install -g kissy

</pre><p>通常测试版不会发送到 npm，这时推荐下载指定的 git 版本到本地目录安装，例如下载 <a href="https://github.com/kissyteam/kissy/archive/master.zip">主干</a> 到 d:/code</p>
<pre>cd d:/code
npm link


</pre><h2 id="xtemplate-示例代码">xtemplate 示例代码<a href="#xtemplate-示例代码" class="anchor">¶</a></h2><pre>this is kissy xtemplate: {{date}}
{{#if n &gt; n*2}}
    {{{no escape}}}
    {{each array}}
        index: {{xindex}}
        count: {{xcount}}
        value: {{value}}
        {{set t = value*2}}
        subValue:
        {{#with this.subValue}}
            {{subSubValue + ../t}}
        {{/with}}
    {{/each}}
{{else}}
    {{#custom_block param}}
        {{custom_tpl param2}}
    {{/custom_block}}
{{/if}}

</pre><h2 id="模板词法-语法">模板词法/语法<a href="#模板词法-语法" class="anchor">¶</a></h2><p>这一步主要是为了下一步构建自定义语言的语法树做准备，这里采用使用工具<strong>自动生成语法解析器</strong>（parser）的方向来做，
如果你打算手写解析器则可以略过此步（事实上可以略过本文）。</p>
<p>由于本文关注前端技术，
故词法以及语法都采用 json 格式描述，词法直接采用正则表达式，
语法采用变形的 <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> 形式，
例如 xtemplate 的 <a href="https://github.com/kissyteam/kissy/blob/master/src/xtemplate/src/parser-grammar.kison">词法语法文件</a></p>
<p>工具采用 kissy 开发的 <a href="http://en.wikipedia.org/wiki/LALR">LALR</a> 语法解析器生成器 <a href="https://github.com/kissyteam/kissy/tree/master/src/kison">kison</a>.</p>
<p>词法关注如何从输入代码中解析出最基本的代码单元（关键词，字符串，数字...），例如 xtemplate 的部分词法</p>
<pre>{
    state: [&#39;t&#39;],
    regexp: /^{{/,
    token: &#39;OPEN&#39;
},
{
    state: [&#39;t&#39;],
    regexp: /^}}/,
    token: &#39;CLOSE&#39;
},
{
    state: [&#39;t&#39;],
    regexp: /^&lt;=/,
    token: &#39;LE&#39;
},
{
    state: [&#39;t&#39;],
    regexp: /^\+/,
    token: &#39;PLUS&#39;
},
{
    state: [&#39;t&#39;],
    regexp: /^[a-zA-Z0-9_$-]+/,
    token: &#39;ID&#39;
},

</pre><p>其中 state 表示单个状态，词法解析过程也是一个状态机变换状态的过程.</p>
<p>而语法解析关注与从词法单元中识别出有效的程序结构，即语法解析树，例如 xtemplate 的部分语法描述：</p>
<pre>{
    symbol: &#39;Expression&#39;,
    rhs: [&#39;ConditionalOrExpression&#39;]
},

{
    symbol: &#39;ConditionalOrExpression&#39;,
    rhs: [&#39;ConditionalAndExpression&#39;]
},
{
    symbol: &#39;program&#39;,
    rhs: [&#39;statements&#39;, &#39;inverse&#39;, &#39;statements&#39;]
},
{
    symbol: &#39;statement&#39;,
    rhs: [&#39;openBlock&#39;, &#39;program&#39;, &#39;closeBlock&#39;]
}

</pre><p>其中对应 BNF 形式中： symbol ::= rhs</p>
<h2 id="构建模板抽象语法树">构建模板抽象语法树<a href="#构建模板抽象语法树" class="anchor">¶</a></h2><p>语法词法只是描述了如何识别模板语言，而构建语法树的过程则需要在语法识别过程中由调用者自行构建，
kison 支持在每个语法规则项中添加动作函数，通过工具在识别语言过程中（遍历<a href="http://en.wikipedia.org/wiki/Parse_tree">语法解析树</a>）
同时有选择性得构建异型<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象语法树</a>，
例如 xtemplate 的树节点构建过程：</p>
<pre>{
    symbol: &#39;program&#39;,
    rhs: [&#39;statements&#39;, &#39;inverse&#39;, &#39;statements&#39;],
    action: function () {
        return new this.yy.ProgramNode(this.lexer.lineNumber, this.$1, this.$3);
    }
},
{
    symbol: &#39;PrimaryExpression&#39;,
    rhs: [&#39;path&#39;]
},
{
    symbol: &#39;RelationalExpression&#39;,
    rhs: [&#39;RelationalExpression&#39;, &#39;LE&#39;, &#39;AdditiveExpression&#39;],
    action: function () {
        return new this.yy.RelationalExpression(this.$1, &#39;&lt;=&#39;, this.$3);
    }
}

</pre><p>其中 最基本的表达式(PrimaryExpression)可以直接是变量词法单元的值，而复杂的比较表达式以及整个程序则是自底向上由子树构建起来.</p>
<p>最后使用 <strong>kison</strong> 命令</p>
<pre>kison -k -g parser.kison

</pre><p>就可以生成模板解析函数模块，大致为：</p>
<pre>KISSY.add(function(){
    function parse(code){
        // ...
    }
    return {parse:parse};
});

</pre><h2 id="模板编译">模板编译<a href="#模板编译" class="anchor">¶</a></h2><p>最后一步即是模板编译过程，将模板代码编译为 javascript 代码，填入数据执行后即可得到真正的渲染 html.</p>
<h3 id="调用-parse">调用 parse<a href="#调用-parse" class="anchor">¶</a></h3><p>经过上一步得到解析函数后，调用</p>
<pre>parse(templateCode)

</pre><p>即得到一棵抽象语法树，例如 xtemplate 的一段代码：</p>
<pre>{{#each data}}
{{#if n === ../n2 * 5}}
{{n + 10.1}}
{{/if}}
{{/each}}

</pre><p>对应的抽象语法树：</p>
<p><img src="http://img04.taobaocdn.com/tps/i4/T1iEDUXmpdXXcyYdHO-265-555.png" alt="xtemplate ast"></p>
<h3 id="翻译代码">翻译代码<a href="#翻译代码" class="anchor">¶</a></h3><p>接着就可以采用 <a href="http://en.wikipedia.org/wiki/Visitor_pattern">visitor</a> 模式将生成具体代码的逻辑写入 visitor 对象，遍历 ast 将对应的子树或节点转换成 javascript 代码，</p>
<p>这步可以继续优雅得采用代码模板，将代码模板的数据替换成模板对应的 javascript 单元。
不过为了不折磨大脑，最后放松下，可以直接采用原生的代码拼接：</p>
<pre>visitor.command=function(node){

    if(node.escapeHtml){
        codes.push(&quot;if(&quot;+node.id+&quot; in data) { ret.push(KISSY.escapeHtml(data.&quot;+node.js+&quot;);) }&quot;+
        &quot; else { KISSY.warn(&#39;not found&#39;)!; }&quot;);
    }else{
    }

};

</pre><p>不过确实还是挺折磨.</p>
<h3 id="离线编译">离线编译<a href="#离线编译" class="anchor">¶</a></h3><p>大多数 DSL 都是推荐在使用前就转换成目标语言，而客户端在不太注重性能的情况下也可以在终端用户使用时在线编译。</p>
<p>xtemplate 通过 <strong>kissy-xtemplate</strong> 命令支持将模板代码离线编译为模板函数模块，这样客户端可以直接require该模块，
省去了客户端编译过程，同时开发中直接面对 html 类似的模板代码，省去了字符串嵌入模板的繁琐。</p>
<p>例如 t.xtpl.html</p>
<pre>{{ offline }} compile

</pre><p>运行</p>
<pre>kissy-xtemplate -n tests -p ./ -w

</pre><p>(-w 表示监控包目录内的 tpl 文件变化, -n 表示包名, -p 表示对应包所在的目录) </p>
<p>可得到 t.js</p>
<pre>KISSY.add(function(){
    function render(data){
    }
    return render;
});

</pre><p>离线编译的一个缺点是编译出来的代码肯定比原生模板大很多，这也正体现了 DSL 节省代码，易读的特性（代码肯定不可读了）。</p>
<h2 id="下一步">下一步<a href="#下一步" class="anchor">¶</a></h2><p>目前存在两大问题：</p>
<h3 id="体积较大">体积较大<a href="#体积较大" class="anchor">¶</a></h3><pre>压缩前 130k， 不过 gzip+compress 后由于生成的重复代码比较多，降到 10k，
不过仍然需要优化生成代码: 减少模板解析器的代码。同时也可优化模板转化为最终代码的大小，这在离线编译情况下很有用。

</pre><h3 id="xtemplate-模块需要拆分">xtemplate 模块需要拆分<a href="#xtemplate-模块需要拆分" class="anchor">¶</a></h3><pre>当选择离线编译，实际上 xtemplate 的编译代码可以不用下载，
可拆分为两个模块: xtemplate/runtime 以及 xtemplate/compiler

这样当选择离线编译时直接use xtemplate/runtime 载入模板的功能基础设施即可。

</pre><h2 id="xtemplate-文档">xtemplate 文档<a href="#xtemplate-文档" class="anchor">¶</a></h2><p><a href="http://docs.kissyui.com/docs/html/api/component/xtemplate/index.html">api</a></p>
<p><a href="http://docs.kissyui.com/docs/html/demo/component/xtemplate/index.html">demo</a></p>
<p><a href="http://docs.kissyui.com/docs/html/tutorials/kissy/component/xtemplate/index.html">tutorial</a></p>
<h2 id="推荐书籍">推荐书籍<a href="#推荐书籍" class="anchor">¶</a></h2><p>感谢这些作者，没有这些书籍， 这个任务不可能完成</p>
<p><a href="http://book.douban.com/subject/3296317/">Compilers: Principles,Techniques and Tools</a></p>
<p><a href="http://book.douban.com/subject/4768014/">DSL In Action</a></p>
<p><a href="http://book.douban.com/subject/10482195/">Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages</a></p>
<h2 id="致谢">致谢<a href="#致谢" class="anchor">¶</a></h2><p>在开发过程中参考一了下工具：</p>
<p><a href="http://velocity.apache.org/">velocity</a></p>
<p><a href="https://developers.google.com/closure/templates/">closure templates</a></p>
<p><a href="http://www.gnu.org/software/bison/">bison</a></p>
<p><a href="http://zaach.github.com/jison/">jison</a></p>
<p><a href="http://handlebarsjs.com/">handlebar</a></p>
<p><a href="http://mustache.github.com/">mustache</a></p>

  </div>
</article>

      </div>
      
    </div>
    <div class="footer-wrapper">
      <footer>
        <p class="footer-powered"><a href="http://spmjs.io">spmjs.io</a> •
<a href="https://github.com/spmjs/spm">spm</a> •
<a href="http://seajs.org">Sea.js</a> •
<a href="http://lab.lepture.com/nico/">nico</a>
        </p>
      </footer>
    </div>
  </body>
  <script src="../../static/js/nprogress.js?nowrap"></script>
  <script>
  (function() {
    NProgress.start();
    window.onload = NProgress.done;
    var ready = function(fn) {
      var doc = document;
      if(doc.addEventListener) {
        doc.addEventListener('DOMContentLoaded', fn, false);
      } else {
        doc.attachEvent('onreadystatechange', fn);
      }
    };
    ready(function() {
      NProgress.inc(0.6);

      seajs.use("../../static/js/arale-qrcode.js?nowrap", function(QRCode) {
        var url = location.href;
        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
          url = url.replace(location.hostname, '192.168.1.15');
        }
        var el = new QRCode({
          text: url,
          render: 'canvas',
          width: 120,
          height: 120
        });
        document.getElementById('qrcode').appendChild(el);
      });
    }, false);
  })();
  </script>
</html>